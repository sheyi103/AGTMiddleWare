// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.13.0
// source: service.sql

package db

import (
	"context"
	"database/sql"
)

const createService = `-- name: CreateService :execresult
INSERT INTO services (
  client_id, client_secret, shortcode_id, user_id, role_id, service_name, service_id,service_interface, service, service_type, product_id, node_id, subscription_id, subscription_description, base_url, datasync_endpoint, notification_endpoint, network_type
) VALUES (
  ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,?, ?, ?, ?, ?,?
)
`

type CreateServiceParams struct {
	ClientID                string                   `json:"client_id"`
	ClientSecret            string                   `json:"client_secret"`
	ShortcodeID             int32                    `json:"shortcode_id"`
	UserID                  int32                    `json:"user_id"`
	RoleID                  int32                    `json:"role_id"`
	ServiceName             string                   `json:"service_name"`
	ServiceID               string                   `json:"service_id"`
	ServiceInterface        ServicesServiceInterface `json:"service_interface"`
	Service                 ServicesService          `json:"service"`
	ServiceType             ServicesServiceType      `json:"service_type"`
	ProductID               string                   `json:"product_id"`
	NodeID                  string                   `json:"node_id"`
	SubscriptionID          string                   `json:"subscription_id"`
	SubscriptionDescription string                   `json:"subscription_description"`
	BaseUrl                 string                   `json:"base_url"`
	DatasyncEndpoint        string                   `json:"datasync_endpoint"`
	NotificationEndpoint    string                   `json:"notification_endpoint"`
	NetworkType             ServicesNetworkType      `json:"network_type"`
}

func (q *Queries) CreateService(ctx context.Context, arg CreateServiceParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createService,
		arg.ClientID,
		arg.ClientSecret,
		arg.ShortcodeID,
		arg.UserID,
		arg.RoleID,
		arg.ServiceName,
		arg.ServiceID,
		arg.ServiceInterface,
		arg.Service,
		arg.ServiceType,
		arg.ProductID,
		arg.NodeID,
		arg.SubscriptionID,
		arg.SubscriptionDescription,
		arg.BaseUrl,
		arg.DatasyncEndpoint,
		arg.NotificationEndpoint,
		arg.NetworkType,
	)
}

const deleteService = `-- name: DeleteService :exec
DELETE FROM services
WHERE id = ?
`

func (q *Queries) DeleteService(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteService, id)
	return err
}

const getService = `-- name: GetService :one
SELECT id, client_id, client_secret, shortcode_id, user_id, role_id, service_name, service_id, service_interface, service, service_type, product_id, node_id, subscription_id, subscription_description, base_url, datasync_endpoint, notification_endpoint, network_type, created_at, updated_at FROM services
WHERE id = ? LIMIT 1
`

func (q *Queries) GetService(ctx context.Context, id int32) (Service, error) {
	row := q.db.QueryRowContext(ctx, getService, id)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.ClientSecret,
		&i.ShortcodeID,
		&i.UserID,
		&i.RoleID,
		&i.ServiceName,
		&i.ServiceID,
		&i.ServiceInterface,
		&i.Service,
		&i.ServiceType,
		&i.ProductID,
		&i.NodeID,
		&i.SubscriptionID,
		&i.SubscriptionDescription,
		&i.BaseUrl,
		&i.DatasyncEndpoint,
		&i.NotificationEndpoint,
		&i.NetworkType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listService = `-- name: ListService :many
SELECT id, client_id, client_secret, shortcode_id, user_id, role_id, service_name, service_id, service_interface, service, service_type, product_id, node_id, subscription_id, subscription_description, base_url, datasync_endpoint, notification_endpoint, network_type, created_at, updated_at FROM services
ORDER BY id
LIMIT ?
OFFSET ?
`

type ListServiceParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListService(ctx context.Context, arg ListServiceParams) ([]Service, error) {
	rows, err := q.db.QueryContext(ctx, listService, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Service{}
	for rows.Next() {
		var i Service
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.ClientSecret,
			&i.ShortcodeID,
			&i.UserID,
			&i.RoleID,
			&i.ServiceName,
			&i.ServiceID,
			&i.ServiceInterface,
			&i.Service,
			&i.ServiceType,
			&i.ProductID,
			&i.NodeID,
			&i.SubscriptionID,
			&i.SubscriptionDescription,
			&i.BaseUrl,
			&i.DatasyncEndpoint,
			&i.NotificationEndpoint,
			&i.NetworkType,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateService = `-- name: UpdateService :execresult
UPDATE services SET  service_name= ?, base_url= ?, datasync_endpoint = ?, notification_endpoint = ?
WHERE id = ?
`

type UpdateServiceParams struct {
	ServiceName          string `json:"service_name"`
	BaseUrl              string `json:"base_url"`
	DatasyncEndpoint     string `json:"datasync_endpoint"`
	NotificationEndpoint string `json:"notification_endpoint"`
	ID                   int32  `json:"id"`
}

func (q *Queries) UpdateService(ctx context.Context, arg UpdateServiceParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateService,
		arg.ServiceName,
		arg.BaseUrl,
		arg.DatasyncEndpoint,
		arg.NotificationEndpoint,
		arg.ID,
	)
}
